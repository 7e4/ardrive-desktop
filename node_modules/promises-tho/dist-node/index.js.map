{"version":3,"file":"index.js","sources":["../dist-src/retry-with-backoff.js","../dist-src/batch-with-progress.js","../dist-src/batch.js","../dist-src/soft-fail-with.js"],"sourcesContent":["import debug from \"debug\";\n/**\n *\n * Wrap any Promise returning function with retries and backoff.\n * Sensible defaults for typical interactive networking\n * scenarios, such as browser requests.\n *\n * Default settings will result in delays of (in ms):\n * 250, 2000, 6750, 16000, 31250\n *\n * @param opts           - options\n * @param opts.tries     - default 6, Maximum attempts, including initial try.\n * @param opts.startMs   - default 250, statring delay after the first failure\n * @param opts.pow       - default 3, Backoff power. float values are fine.\n * @param opts.maxMs     - default 300000 (5 minutes), upper limit on the delay. Won't be reached with default settings.\n * @param opts.jitter    - default 0.25, amount of jitter to apply. Removes a random value (0-N*delay) from delay.\n * @param func           - the function to wrap.\n *\n */\nexport function retryWithBackoff(optsOrFn, fn) {\n    if (!fn && typeof optsOrFn === 'function') {\n        fn = optsOrFn;\n        optsOrFn = undefined;\n    }\n    // somehow even with this, fn will be \" T | undefined \" in the async function below. \n    if (!fn || typeof fn !== 'function') {\n        throw new Error('Invalid arguments');\n    }\n    const log = debug('promises-tho:retry-with-backoff');\n    const { tries, startMs, pow, maxMs, jitter } = Object.assign({ tries: 6, startMs: 250, pow: 3, maxMs: 300000, jitter: 0.25 }, optsOrFn);\n    return async function (...args) {\n        let errors = 0;\n        while (true) {\n            try {\n                return await fn(...args);\n            }\n            catch (e) {\n                if (++errors === tries) {\n                    throw (e);\n                }\n                else {\n                    let delay = Math.min(maxMs, startMs * Math.pow(errors, pow));\n                    delay = delay - (Math.random() * delay * jitter);\n                    console.error(e);\n                    log(`${fn.name} failed, retrying in ${delay.toFixed(0)}ms`);\n                    await new Promise(res => setTimeout(res, delay));\n                }\n            }\n        }\n    };\n}\n","import debug from 'debug';\n/**\n * Wraps a Promise returning function that you want to call in batches.\n * This version passes back intermediate results to the caller, who can do something\n * with the partially completed batch results and pass back in the Job to continue.\n * Could be used to update a UI, start some depedent work, etc, without having to wait\n * for the whole batch to complete.\n *\n * Note: fn must take exactly one argument. If you need to use a function taking\n * multiple arguments, make a small wrapper.\n *\n * @param opts options\n * @param opts.batchSize default 4. the number of concurrent executions of fn\n * @param opts.batchDelayMs default 150. milliseconds to delay between batches. Only applied from the 2d batch onwards.\n * @param fn the function to wrap\n *\n */\nexport function batchWithProgress(optsOrFn, fn) {\n    if (!fn) {\n        fn = optsOrFn;\n        optsOrFn = undefined;\n    }\n    const log = debug('promises-tho:batch-with-progress');\n    const options = Object.assign({\n        batchSize: 4,\n        batchDelayMs: 150,\n    }, optsOrFn);\n    return async function (job) {\n        // Copy job as to not mutate our arguments, \n        // we shouldn't modify the arrays directly either. \n        // as the caller may want to keep around the original \n        // data they pass in.\n        // Check for caller fck up \n        if (job.inProgress === false) {\n            throw new Error('This job is already completed.');\n        }\n        const current = Object.assign({ inProgress: true, batched: 0 }, job);\n        if (current.pending.length > 0) {\n            if (current.inProgress) {\n                // we are in progress, want to delay a bit before next batch.\n                // This wont be set on the first batch.\n                const delayMs = options.batchDelayMs;\n                await new Promise(res => setTimeout(res, delayMs));\n            }\n            const t1 = Date.now();\n            const batch = current.pending.slice(0, options.batchSize).map(x => fn(x));\n            const results = await Promise.all(batch);\n            current.completed = current.completed.concat(results);\n            current.pending = current.pending.slice(options.batchSize);\n            current.inProgress === current.pending.length > 0;\n            current.batched = batch.length;\n            log(`Batch of ${results.length} took ${(Date.now() - t1) / 1000} seconds`);\n        }\n        if (!current.inProgress) {\n            log(`Batch complete`);\n        }\n        return current;\n    };\n}\n","import debug from \"debug\";\n/**\n * Wraps a Promise returning function that you want to call in batches.\n * This version will only return once the entire batch is complete.\n *\n * Note: fn must take exactly one argument. If you need to use a function taking\n * multiple arguments, make a small wrapper.\n *\n * @param opts options\n * @param opts.batchSize default 4. the number of concurrent executions of fn\n * @param opts.batchDelayMs default 150. milliseconds to delay between batches. Only applied from the 2d batch onwards.\n * @param fn the function to wrap\n *\n */\nexport function batch(optsOrFn, fn, opts) {\n    if (!fn) {\n        fn = optsOrFn;\n        optsOrFn = undefined;\n    }\n    const log = debug('promises-tho:batch');\n    const options = Object.assign({\n        batchSize: 4,\n        batchDelayMs: 150,\n    }, optsOrFn);\n    return async function (requests) {\n        const context = {\n            pending: requests,\n            completed: [],\n        };\n        const t0 = Date.now();\n        while (context.pending.length > 0) {\n            const t1 = Date.now();\n            const batch = context.pending.slice(0, options.batchSize).map(x => fn(x));\n            const results = await Promise.all(batch);\n            context.completed = context.completed.concat(results);\n            context.pending = context.pending.slice(options.batchSize);\n            log(`Batch of ${results.length} took ${(Date.now() - t1) / 1000} seconds`);\n            if (context.pending.length > 0) {\n                const delayMs = options.batchDelayMs;\n                log(`Delaying ${delayMs / 1000} seconds between batches`);\n                await new Promise(res => setTimeout(res, delayMs));\n            }\n        }\n        log(`Total Batch of ${context.completed.length} took ${(Date.now() - t0) / 1000} seconds`);\n        return context.completed;\n    };\n}\n","/**\n * Wraps a promise returning function and returns a default value\n * when it errors.\n *\n * @param defval The default value to return if the promise function errors\n * @param func The promise returning function.\n */\nexport function softFailWith(defval, func) {\n    return (...args) => func(...args).catch(() => defval);\n}\n"],"names":["retryWithBackoff","optsOrFn","fn","undefined","Error","log","debug","tries","startMs","pow","maxMs","jitter","Object","assign","args","errors","e","delay","Math","min","random","console","error","name","toFixed","Promise","res","setTimeout","batchWithProgress","options","batchSize","batchDelayMs","job","inProgress","current","batched","pending","length","delayMs","t1","Date","now","batch","slice","map","x","results","all","completed","concat","opts","requests","context","t0","softFailWith","defval","func","catch"],"mappings":"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"}