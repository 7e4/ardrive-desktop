import { OneArgFunctionReturningPromise } from './types';
export interface BatchJob<P, R> {
    pending: P[];
    completed: R[];
    batched?: number;
    inProgress?: boolean;
}
interface Options {
    batchSize?: number;
    batchDelayMs?: number;
}
/**
 * Wraps a Promise returning function that you want to call in batches.
 * This version passes back intermediate results to the caller, who can do something
 * with the partially completed batch results and pass back in the Job to continue.
 * Could be used to update a UI, start some depedent work, etc, without having to wait
 * for the whole batch to complete.
 *
 * Note: fn must take exactly one argument. If you need to use a function taking
 * multiple arguments, make a small wrapper.
 *
 * @param opts options
 * @param opts.batchSize default 4. the number of concurrent executions of fn
 * @param opts.batchDelayMs default 150. milliseconds to delay between batches. Only applied from the 2d batch onwards.
 * @param fn the function to wrap
 *
 */
export declare function batchWithProgress<P, R>(optsOrFn: Options | OneArgFunctionReturningPromise<P, R>, fn?: OneArgFunctionReturningPromise<P, R>): (job: BatchJob<P, R>) => Promise<BatchJob<P, R>>;
export {};
