{"version":3,"file":"index.js","sources":["../dist-src/retry-with-backoff.js","../dist-src/batch-with-progress.js","../dist-src/batch.js","../dist-src/soft-fail-with.js"],"sourcesContent":["import debug from \"debug\";\n/**\n *\n * Wrap any Promise returning function with retries and backoff.\n * Sensible defaults for typical interactive networking\n * scenarios, such as browser requests.\n *\n * Default settings will result in delays of (in ms):\n * 250, 2000, 6750, 16000, 31250\n *\n * @param opts           - options\n * @param opts.tries     - default 6, Maximum attempts, including initial try.\n * @param opts.startMs   - default 250, statring delay after the first failure\n * @param opts.pow       - default 3, Backoff power. float values are fine.\n * @param opts.maxMs     - default 300000 (5 minutes), upper limit on the delay. Won't be reached with default settings.\n * @param opts.jitter    - default 0.25, amount of jitter to apply. Removes a random value (0-N*delay) from delay.\n * @param func           - the function to wrap.\n *\n */\nexport function retryWithBackoff(optsOrFn, fn) {\n    if (!fn && typeof optsOrFn === 'function') {\n        fn = optsOrFn;\n        optsOrFn = undefined;\n    }\n    // somehow even with this, fn will be \" T | undefined \" in the async function below. \n    if (!fn || typeof fn !== 'function') {\n        throw new Error('Invalid arguments');\n    }\n    const log = debug('promises-tho:retry-with-backoff');\n    const { tries, startMs, pow, maxMs, jitter } = Object.assign({ tries: 6, startMs: 250, pow: 3, maxMs: 300000, jitter: 0.25 }, optsOrFn);\n    return async function (...args) {\n        let errors = 0;\n        while (true) {\n            try {\n                return await fn(...args);\n            }\n            catch (e) {\n                if (++errors === tries) {\n                    throw (e);\n                }\n                else {\n                    let delay = Math.min(maxMs, startMs * Math.pow(errors, pow));\n                    delay = delay - (Math.random() * delay * jitter);\n                    console.error(e);\n                    log(`${fn.name} failed, retrying in ${delay.toFixed(0)}ms`);\n                    await new Promise(res => setTimeout(res, delay));\n                }\n            }\n        }\n    };\n}\n","import debug from 'debug';\n/**\n * Wraps a Promise returning function that you want to call in batches.\n * This version passes back intermediate results to the caller, who can do something\n * with the partially completed batch results and pass back in the Job to continue.\n * Could be used to update a UI, start some depedent work, etc, without having to wait\n * for the whole batch to complete.\n *\n * Note: fn must take exactly one argument. If you need to use a function taking\n * multiple arguments, make a small wrapper.\n *\n * @param opts options\n * @param opts.batchSize default 4. the number of concurrent executions of fn\n * @param opts.batchDelayMs default 150. milliseconds to delay between batches. Only applied from the 2d batch onwards.\n * @param fn the function to wrap\n *\n */\nexport function batchWithProgress(optsOrFn, fn) {\n    if (!fn) {\n        fn = optsOrFn;\n        optsOrFn = undefined;\n    }\n    const log = debug('promises-tho:batch-with-progress');\n    const options = Object.assign({\n        batchSize: 4,\n        batchDelayMs: 150,\n    }, optsOrFn);\n    return async function (job) {\n        // Copy job as to not mutate our arguments, \n        // we shouldn't modify the arrays directly either. \n        // as the caller may want to keep around the original \n        // data they pass in.\n        // Check for caller fck up \n        if (job.inProgress === false) {\n            throw new Error('This job is already completed.');\n        }\n        const current = Object.assign({ inProgress: true, batched: 0 }, job);\n        if (current.pending.length > 0) {\n            if (current.inProgress) {\n                // we are in progress, want to delay a bit before next batch.\n                // This wont be set on the first batch.\n                const delayMs = options.batchDelayMs;\n                await new Promise(res => setTimeout(res, delayMs));\n            }\n            const t1 = Date.now();\n            const batch = current.pending.slice(0, options.batchSize).map(x => fn(x));\n            const results = await Promise.all(batch);\n            current.completed = current.completed.concat(results);\n            current.pending = current.pending.slice(options.batchSize);\n            current.inProgress === current.pending.length > 0;\n            current.batched = batch.length;\n            log(`Batch of ${results.length} took ${(Date.now() - t1) / 1000} seconds`);\n        }\n        if (!current.inProgress) {\n            log(`Batch complete`);\n        }\n        return current;\n    };\n}\n","import debug from \"debug\";\n/**\n * Wraps a Promise returning function that you want to call in batches.\n * This version will only return once the entire batch is complete.\n *\n * Note: fn must take exactly one argument. If you need to use a function taking\n * multiple arguments, make a small wrapper.\n *\n * @param opts options\n * @param opts.batchSize default 4. the number of concurrent executions of fn\n * @param opts.batchDelayMs default 150. milliseconds to delay between batches. Only applied from the 2d batch onwards.\n * @param fn the function to wrap\n *\n */\nexport function batch(optsOrFn, fn, opts) {\n    if (!fn) {\n        fn = optsOrFn;\n        optsOrFn = undefined;\n    }\n    const log = debug('promises-tho:batch');\n    const options = Object.assign({\n        batchSize: 4,\n        batchDelayMs: 150,\n    }, optsOrFn);\n    return async function (requests) {\n        const context = {\n            pending: requests,\n            completed: [],\n        };\n        const t0 = Date.now();\n        while (context.pending.length > 0) {\n            const t1 = Date.now();\n            const batch = context.pending.slice(0, options.batchSize).map(x => fn(x));\n            const results = await Promise.all(batch);\n            context.completed = context.completed.concat(results);\n            context.pending = context.pending.slice(options.batchSize);\n            log(`Batch of ${results.length} took ${(Date.now() - t1) / 1000} seconds`);\n            if (context.pending.length > 0) {\n                const delayMs = options.batchDelayMs;\n                log(`Delaying ${delayMs / 1000} seconds between batches`);\n                await new Promise(res => setTimeout(res, delayMs));\n            }\n        }\n        log(`Total Batch of ${context.completed.length} took ${(Date.now() - t0) / 1000} seconds`);\n        return context.completed;\n    };\n}\n","/**\n * Wraps a promise returning function and returns a default value\n * when it errors.\n *\n * @param defval The default value to return if the promise function errors\n * @param func The promise returning function.\n */\nexport function softFailWith(defval, func) {\n    return (...args) => func(...args).catch(() => defval);\n}\n"],"names":[],"mappings":"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"}