import debug from 'debug';

/**
 *
 * Wrap any Promise returning function with retries and backoff.
 * Sensible defaults for typical interactive networking
 * scenarios, such as browser requests.
 *
 * Default settings will result in delays of (in ms):
 * 250, 2000, 6750, 16000, 31250
 *
 * @param opts           - options
 * @param opts.tries     - default 6, Maximum attempts, including initial try.
 * @param opts.startMs   - default 250, statring delay after the first failure
 * @param opts.pow       - default 3, Backoff power. float values are fine.
 * @param opts.maxMs     - default 300000 (5 minutes), upper limit on the delay. Won't be reached with default settings.
 * @param opts.jitter    - default 0.25, amount of jitter to apply. Removes a random value (0-N*delay) from delay.
 * @param func           - the function to wrap.
 *
 */
function retryWithBackoff(optsOrFn, fn) {
    if (!fn && typeof optsOrFn === 'function') {
        fn = optsOrFn;
        optsOrFn = undefined;
    }
    // somehow even with this, fn will be " T | undefined " in the async function below. 
    if (!fn || typeof fn !== 'function') {
        throw new Error('Invalid arguments');
    }
    const log = debug('promises-tho:retry-with-backoff');
    const { tries, startMs, pow, maxMs, jitter } = Object.assign({ tries: 6, startMs: 250, pow: 3, maxMs: 300000, jitter: 0.25 }, optsOrFn);
    return async function (...args) {
        let errors = 0;
        while (true) {
            try {
                return await fn(...args);
            }
            catch (e) {
                if (++errors === tries) {
                    throw (e);
                }
                else {
                    let delay = Math.min(maxMs, startMs * Math.pow(errors, pow));
                    delay = delay - (Math.random() * delay * jitter);
                    console.error(e);
                    log(`${fn.name} failed, retrying in ${delay.toFixed(0)}ms`);
                    await new Promise(res => setTimeout(res, delay));
                }
            }
        }
    };
}

/**
 * Wraps a Promise returning function that you want to call in batches.
 * This version passes back intermediate results to the caller, who can do something
 * with the partially completed batch results and pass back in the Job to continue.
 * Could be used to update a UI, start some depedent work, etc, without having to wait
 * for the whole batch to complete.
 *
 * Note: fn must take exactly one argument. If you need to use a function taking
 * multiple arguments, make a small wrapper.
 *
 * @param opts options
 * @param opts.batchSize default 4. the number of concurrent executions of fn
 * @param opts.batchDelayMs default 150. milliseconds to delay between batches. Only applied from the 2d batch onwards.
 * @param fn the function to wrap
 *
 */
function batchWithProgress(optsOrFn, fn) {
    if (!fn) {
        fn = optsOrFn;
        optsOrFn = undefined;
    }
    const log = debug('promises-tho:batch-with-progress');
    const options = Object.assign({
        batchSize: 4,
        batchDelayMs: 150,
    }, optsOrFn);
    return async function (job) {
        // Copy job as to not mutate our arguments, 
        // we shouldn't modify the arrays directly either. 
        // as the caller may want to keep around the original 
        // data they pass in.
        // Check for caller fck up 
        if (job.inProgress === false) {
            throw new Error('This job is already completed.');
        }
        const current = Object.assign({ inProgress: true, batched: 0 }, job);
        if (current.pending.length > 0) {
            if (current.inProgress) {
                // we are in progress, want to delay a bit before next batch.
                // This wont be set on the first batch.
                const delayMs = options.batchDelayMs;
                await new Promise(res => setTimeout(res, delayMs));
            }
            const t1 = Date.now();
            const batch = current.pending.slice(0, options.batchSize).map(x => fn(x));
            const results = await Promise.all(batch);
            current.completed = current.completed.concat(results);
            current.pending = current.pending.slice(options.batchSize);
            current.inProgress === current.pending.length > 0;
            current.batched = batch.length;
            log(`Batch of ${results.length} took ${(Date.now() - t1) / 1000} seconds`);
        }
        if (!current.inProgress) {
            log(`Batch complete`);
        }
        return current;
    };
}

/**
 * Wraps a Promise returning function that you want to call in batches.
 * This version will only return once the entire batch is complete.
 *
 * Note: fn must take exactly one argument. If you need to use a function taking
 * multiple arguments, make a small wrapper.
 *
 * @param opts options
 * @param opts.batchSize default 4. the number of concurrent executions of fn
 * @param opts.batchDelayMs default 150. milliseconds to delay between batches. Only applied from the 2d batch onwards.
 * @param fn the function to wrap
 *
 */
function batch(optsOrFn, fn, opts) {
    if (!fn) {
        fn = optsOrFn;
        optsOrFn = undefined;
    }
    const log = debug('promises-tho:batch');
    const options = Object.assign({
        batchSize: 4,
        batchDelayMs: 150,
    }, optsOrFn);
    return async function (requests) {
        const context = {
            pending: requests,
            completed: [],
        };
        const t0 = Date.now();
        while (context.pending.length > 0) {
            const t1 = Date.now();
            const batch = context.pending.slice(0, options.batchSize).map(x => fn(x));
            const results = await Promise.all(batch);
            context.completed = context.completed.concat(results);
            context.pending = context.pending.slice(options.batchSize);
            log(`Batch of ${results.length} took ${(Date.now() - t1) / 1000} seconds`);
            if (context.pending.length > 0) {
                const delayMs = options.batchDelayMs;
                log(`Delaying ${delayMs / 1000} seconds between batches`);
                await new Promise(res => setTimeout(res, delayMs));
            }
        }
        log(`Total Batch of ${context.completed.length} took ${(Date.now() - t0) / 1000} seconds`);
        return context.completed;
    };
}

/**
 * Wraps a promise returning function and returns a default value
 * when it errors.
 *
 * @param defval The default value to return if the promise function errors
 * @param func The promise returning function.
 */
function softFailWith(defval, func) {
    return (...args) => func(...args).catch(() => defval);
}

export { batch, batchWithProgress, retryWithBackoff, softFailWith };
//# sourceMappingURL=index.js.map
