import { retryWithBackoff, batch, softFailWith } from 'promises-tho';

/**
 * Create a new contract from a contract source file and an initial state.
 * Returns the contract id.
 *
 * @param arweave       an Arweave client instance
 * @param wallet        a wallet private or public key
 * @param contractSrc   the contract source as string.
 * @param initState     the contract initial state, as a JSON string.
 */
async function createContract(arweave, wallet, contractSrc, initState, minFee) {
    let srcTx = await arweave.createTransaction({ data: contractSrc }, wallet);
    srcTx.addTag('App-Name', 'SmartWeaveContractSource');
    srcTx.addTag('App-Version', '0.3.0');
    srcTx.addTag('Content-Type', 'application/javascript');
    await arweave.transactions.sign(srcTx, wallet);
    const response = await arweave.transactions.post(srcTx);
    if ((response.status == 200) || (response.status == 208))
        return createContractFromTx(arweave, wallet, srcTx.id, initState, minFee);
    else
        throw new Error(`Unable to write Contract Source.`);
}
/**
 * Create a new conntract from an existing contract source tx, with an initial state.
 * Returns the contract id.
 *
 * @param arweave   an Arweave client instance
 * @param wallet    a wallet private or public key
 * @param srcTxId   the contract source Tx id.
 * @param state     the initial state, as a JSON string.
 */
async function createContractFromTx(arweave, wallet, srcTxId, state, minFee) {
    // Create a contract from a stored source TXID, setting the default state.
    let contractTX = await arweave.createTransaction({ data: state }, wallet);
    contractTX.addTag('App-Name', 'SmartWeaveContract');
    contractTX.addTag('App-Version', '0.3.0');
    contractTX.addTag('Contract-Src', srcTxId);
    contractTX.addTag('Content-Type', 'application/json');
    if (minFee) {
        contractTX.addTag('Min-Fee', minFee.toString());
    }
    await arweave.transactions.sign(contractTX, wallet);
    const response = await arweave.transactions.post(contractTX);
    if ((response.status == 200) || (response.status == 208))
        return contractTX.id;
    else
        throw new Error(`Unable to write Contract Initial State`);
}

function getTag(tx, name) {
    let tags = tx.get('tags');
    for (let i = 0; i < tags.length; i++) {
        // decoding tags can throw on invalid utf8 data.
        try {
            if (tags[i].get('name', { decode: true, string: true }) == name)
                return tags[i].get('value', { decode: true, string: true });
        }
        catch (e) {
        }
    }
    return false;
}
/**
 * Unpacks string tags from a Tx and puts in a KV map
 * Tags that appear multiple times will be converted to an
 * array of string values, ordered as they appear in the tx.
 *
 * @param tx
 */
function unpackTags(tx) {
    let tags = tx.get('tags');
    let result = {};
    for (let i = 0; i < tags.length; i++) {
        try {
            const name = tags[i].get('name', { decode: true, string: true });
            const value = tags[i].get('value', { decode: true, string: true });
            if (!result.hasOwnProperty(name)) {
                result[name] = value;
                continue;
            }
            result[name] = [...result[name], value];
        }
        catch (e) {
            // ignore tags with invalid utf-8 strings in key or value.
        }
    }
    return result;
}
function arrayToHex(arr) {
    let str = '';
    for (let i = 0; i < arr.length; i++) {
        str += ("0" + arr[i].toString(16)).slice(-2);
    }
    return str;
}

/**
 * Executes a single interaction against the contract source code and state, and
 * returns the new state, or 'false' if there was an error.
 *
 * Callers should replay all interactions in the correct order to get the correct
 * state to execute against.
 *
 * @param contractSrc   the source code of the contract
 * @param input         the input interaction, should be a plain Js object
 * @param state         the current state of the contract
 * @param caller        the wallet address of the caller who is interacting with the contract
 */
async function execute(handler, interaction, state) {
    try {
        const result = await handler(state, interaction);
        if (result && (result.state || result.result)) {
            return {
                type: 'ok',
                result: result.result,
                state: result.state || state
            };
        }
        // Will be caught below as unexpected exception.
        throw new Error(`Unexpected result from contract: ${JSON.stringify(result)}`);
    }
    catch (err) {
        if (err.name === 'ContractError') {
            return {
                type: 'error',
                result: err.message,
                state: state,
            };
        }
        return {
            type: 'exception',
            result: `${(err && err.stack) || (err && err.message)}`,
            state: state,
        };
    }
}

/**
 * Queries all interaction transactions and replays a contract to its latest state.
 *
 * If height is provided, will replay only to that block height.
 *
 * @param arweave     an Arweave client instance
 * @param contractId  the Transaction Id of the contract
 * @param height      if specified the contract will be replayed only to this block height
 */
async function readContract(arweave, contractId, height = Number.POSITIVE_INFINITY) {
    const contractInfo = await loadContract(arweave, contractId);
    let state;
    try {
        state = JSON.parse(contractInfo.initState);
    }
    catch (e) {
        throw new Error(`Unable to parse initial state for contract: ${contractId}`);
    }
    // Load all the interaction txs relevant to this contract. 
    // This can be made a lot cleaner with some GraphQL features, 
    // (block info in results, pagination)
    // but for now, we stick with arql and use some utils to help 
    // with concurency and retry on errors. 
    // (we can be firing off thousands of requests here) 
    const arql = {
        op: 'and',
        expr1: {
            op: 'equals',
            expr1: 'App-Name',
            expr2: 'SmartWeaveAction',
        },
        expr2: {
            op: 'equals',
            expr1: 'Contract',
            expr2: contractId
        }
    };
    let transactions = await arweave.arql(arql);
    const getTxInfoFn = retryWithBackoff({ tries: 3, startMs: 1000 }, (id) => getFullTxInfo(arweave, id));
    const batcher = batch({ batchDelayMs: 50, batchSize: 3 }, softFailWith(undefined, getTxInfoFn));
    console.log(`Query returned ${transactions.length} interactions`);
    let unconfirmed = await batcher(transactions);
    console.log(`Recieved info for ${unconfirmed.length} transactions`);
    // Filter out txs that are not confirmed yet, not found, 
    // or are below the height we are replaying to.
    let txInfos = unconfirmed
        .filter(x => x &&
        x.info.confirmed &&
        x.info.confirmed.block_height <= height);
    console.log(`Replaying ${txInfos.length} confirmed interactions`);
    txInfos.sort((a, b) => a.sortKey.localeCompare(b.sortKey));
    const { handler, swGlobal } = contractInfo;
    for (let i = 0; i < txInfos.length; i++) {
        let input;
        try {
            input = getTag(txInfos[i].tx, 'Input');
            input = JSON.parse(input);
        }
        catch (e) { }
        if (!input) {
            console.warn(`Skipping tx with missing or invalid Input tag - ${txInfos[i].id}`);
            continue;
        }
        const interaction = {
            input: input,
            caller: txInfos[i].from,
        };
        swGlobal._activeTx = txInfos[i];
        const result = await execute(handler, interaction, state);
        if (result.type === 'exception') {
            console.warn(`${result.result}`);
            console.warn(`Executing of interaction: ${txInfos[i].id} threw exception.`);
        }
        if (result.type === 'error') {
            console.warn(`${result.result}`);
            console.warn(`Executing of interaction: ${txInfos[i].id} returned error.`);
        }
        state = result.state;
    }
    return state;
}
// This gets the full Tx Info, and calcutes a sort key.
// It needs to get the block_height and indep_hash from
// the status endpoint as well as the tx itself. Returns 
// undefined if the transactions is not confirmed. 
async function getFullTxInfo(arweave, id) {
    const [tx, info] = await Promise.all([
        arweave.transactions.get(id).catch(e => {
            if (e.type === 'TX_PENDING') {
                return undefined;
            }
            throw (e);
        }),
        arweave.transactions.getStatus(id)
    ]);
    if (!tx || !info || !info.confirmed) {
        return undefined;
    }
    // Construct a string that will lexographically sort.
    // { block_height, sha256(block_indep_hash + txid) }
    // pad block height to 12 digits and convert hash value 
    // to a hex string.
    const blockHashBytes = arweave.utils.b64UrlToBuffer(info.confirmed.block_indep_hash);
    const txIdBytes = arweave.utils.b64UrlToBuffer(id);
    const concatted = arweave.utils.concatBuffers([blockHashBytes, txIdBytes]);
    const hashed = arrayToHex(await arweave.crypto.hash(concatted));
    const block_height = `000000${info.confirmed.block_height}`.slice(-12);
    const sortKey = `${block_height},${hashed}`;
    return { tx, info, id: tx.id, sortKey, from: await arweave.wallets.ownerToAddress(tx.owner) };
}

/**
 *
 * This class is be exposed as a global for contracts
 * as 'SmartWeave' and provides an API for getting further
 * information or using utility and crypto functions from
 * inside the contracts execution.
 *
 * It provides an api:
 *
 * - SmartWeave.transaction.id
 * - SmartWeave.transaction.reward
 * - SmartWeave.block.height
 * - etc
 *
 * and access to some of the arweave utils:
 * - SmartWeave.arweave.utils
 * - SmartWeave.arweave.crypto
 * - SmartWeave.arweave.wallets
 * - SmartWeave.arweave.ar
 *
 */
class SmartWeaveGlobal {
    constructor(arweave) {
        this.arweave = {
            ar: arweave.ar,
            utils: arweave.utils,
            wallets: arweave.wallets,
            crypto: arweave.crypto,
        };
        this.transaction = new Transaction(this);
        this.block = new Block(this);
        this.contracts = {
            readContractState: (contractId, height) => readContract(arweave, contractId, height || (this._isDryRunning ? Number.POSITIVE_INFINITY : this.block.height))
        };
    }
    get _isDryRunning() {
        return !this._activeTx;
    }
}
class Transaction {
    constructor(global) {
        this.global = global;
    }
    get id() {
        if (!this.global._activeTx) {
            throw new Error('No current Tx');
        }
        return this.global._activeTx.id;
    }
    get owner() {
        if (!this.global._activeTx) {
            throw new Error('No current Tx');
        }
        return this.global._activeTx.tx.owner;
    }
    get target() {
        if (!this.global._activeTx) {
            throw new Error('No current Tx');
        }
        return this.global._activeTx.tx.target;
    }
    get tags() {
        if (!this.global._activeTx) {
            throw new Error('No current Tx');
        }
        return unpackTags(this.global._activeTx.tx);
    }
    get quantity() {
        if (!this.global._activeTx) {
            throw new Error('No current Tx');
        }
        return this.global._activeTx.tx.quantity;
    }
    get reward() {
        if (!this.global._activeTx) {
            throw new Error('No current Tx');
        }
        return this.global._activeTx.tx.reward;
    }
}
class Block {
    constructor(global) {
        this.global = global;
    }
    get height() {
        if (!this.global._activeTx) {
            throw new Error('No current Tx');
        }
        return this.global._activeTx.info.confirmed.block_height;
    }
    get indep_hash() {
        if (!this.global._activeTx) {
            throw new Error('No current Tx');
        }
        return this.global._activeTx.info.confirmed.block_indep_hash;
    }
}

/**
 * Loads the contract source, initial state and other parameters
 *
 * @param arweave     an Arweave client instance
 * @param contractID  the Transaction Id of the contract
 */
async function loadContract(arweave, contractID) {
    try {
        // Generate an object containing the details about a contract in one place.
        const contractTX = await arweave.transactions.get(contractID);
        const contractSrcTXID = getTag(contractTX, 'Contract-Src');
        const minFee = getTag(contractTX, 'Min-Fee');
        const contractSrcTX = await arweave.transactions.get(contractSrcTXID);
        const contractSrc = contractSrcTX.get('data', { decode: true, string: true });
        const state = contractTX.get('data', { decode: true, string: true });
        //console.log(`${contractSrcTXID} (Src) \n`, contractSrc);
        //console.log(`${contractID} (State) \n`, state);
        const { handler, swGlobal } = createContractExecutionEnvironment(arweave, contractSrc);
        return {
            id: contractID,
            contractSrc: contractSrc,
            initState: state,
            minFee: minFee,
            contractTX,
            handler,
            swGlobal
        };
    }
    catch (e) {
        console.error(e);
        throw new Error(`Unable to load contract ${contractID}.`);
    }
}
/**
 * Translates a contract source code into a Js function that can be called, and sets
 * up two globals, SmartWeave and the ContractError exception.
 *
 * At the moment this uses the Function() constructor (basically the same as eval),
 * But the design is geared toward switching to Realms or something like
 * https://github.com/justjake/quickjs-emscripten. (probably the latter)
 *
 * In the current implemention, using Function(), the 'globals' are actually
 * just lexically scoped vars, unique to each instance of a contract.
 *
 * @param contractSrc the javascript source for the contract. Must declare a handle() function
 */
function createContractExecutionEnvironment(arweave, contractSrc) {
    // Convert from ES Module format to something we can run inside a Function.
    // just removes the `export` keyword and adds ;return handle to the end of the function.
    // We also assign the passed in SmartWeaveGlobal to SmartWeave, and declare 
    // the ContractError exception. 
    // We then use `new Function()` which we can call and get back the returned handle function
    // which has access to the per-instance globals. 
    contractSrc = contractSrc.replace(/export\s+async\s+function\s+handle/gmu, 'async function handle');
    contractSrc = contractSrc.replace(/export\s+function\s+handle/gmu, 'function handle');
    const ContractErrorDef = `class ContractError extends Error { constructor(message) { super(message); this.name = 'ContractError' } };`;
    const ContractAssertDef = `function ContractAssert(cond, message) { if (!cond) throw new ContractError(message) };`;
    const returningSrc = `const SmartWeave = swGlobal;\n\n${ContractErrorDef}\n${ContractAssertDef}\n${contractSrc}\n\n;return handle;`;
    const swGlobal = new SmartWeaveGlobal(arweave);
    const getContractFunction = new Function('swGlobal', returningSrc);
    //console.log(returningSrc);
    return {
        handler: getContractFunction(swGlobal),
        swGlobal
    };
}

/**
 * Writes an interaction on the blockchain.
 *
 * This simply creates an interaction tx and posts it.
 * It does not need to know the current state of the contract.
 *
 * @param arweave       an Arweave client instance
 * @param wallet        a wallet private key
 * @param contractId    the Transaction Id of the contract
 * @param input         the interaction input, will be serialized as Json.
 */
async function interactWrite(arweave, wallet, contractId, input) {
    // Use a random value in the data body. We must put
    // _something_ in the body, because a tx must have data or target
    // to be valid. The value doesn't matter, but something sorta random
    // helps because it will generate a different txid.
    let interactionTx = await arweave.createTransaction({
        data: Math.random()
            .toString()
            .slice(-4)
    }, wallet);
    if (!input) {
        throw new Error(`Input should be a truthy value: ${JSON.stringify(input)}`);
    }
    interactionTx.addTag('App-Name', 'SmartWeaveAction');
    interactionTx.addTag('App-Version', '0.3.0');
    interactionTx.addTag('Contract', contractId);
    interactionTx.addTag('Input', JSON.stringify(input));
    await arweave.transactions.sign(interactionTx, wallet);
    const response = await arweave.transactions.post(interactionTx);
    if (response.status != 200)
        return false;
    return interactionTx.id;
}
/**
 * This will load a contract to its latest state, and do a dry run of an interaction,
 * without writing anything to the chain.
 *
 * @param arweave       an Arweave client instance
 * @param wallet        a wallet private or public key
 * @param contractId    the Transaction Id of the contract
 * @param input         the interaction input.
 */
async function interactWriteDryRun(arweave, wallet, contractId, input) {
    const contractInfo = await loadContract(arweave, contractId);
    const latestState = await readContract(arweave, contractId);
    const from = await arweave.wallets.jwkToAddress(wallet);
    const interaction = {
        input: input,
        caller: from
    };
    return execute(contractInfo.handler, interaction, latestState);
}
/**
 * This will load a contract to its latest state, and execute a read interaction that
 * does not change any state.
 *
 * @param arweave       an Arweave client instance
 * @param wallet        a wallet private or public key
 * @param contractId    the Transaction Id of the contract
 * @param input         the interaction input.
 */
async function interactRead(arweave, wallet, contractId, input) {
    const contractInfo = await loadContract(arweave, contractId);
    const latestState = await readContract(arweave, contractId);
    const from = await arweave.wallets.jwkToAddress(wallet);
    const interaction = {
        input: input,
        caller: from
    };
    const result = await execute(contractInfo.handler, interaction, latestState);
    return result.result;
}

/**
 * Given an map of address->balance, select one random address
 * weighted by the amount of tokens they hold.
 *
 * @param balances  A balances object, where the key is address and the value is the number of tokens they hold
 */
function selectWeightedPstHolder(balances) {
    // Count the total tokens
    let totalTokens = 0;
    for (const address of Object.keys(balances)) {
        totalTokens += balances[address];
    }
    // Create a copy of balances where the amount each holder owns is represented
    // by a value 0-1.
    const weighted = {};
    for (const address of Object.keys(balances)) {
        weighted[address] = balances[address] / totalTokens;
    }
    let sum = 0;
    const r = Math.random();
    for (const address of Object.keys(weighted)) {
        sum += weighted[address];
        if (r <= sum && weighted[address] > 0) {
            return address;
        }
    }
    throw new Error(`Unable to select token holder`);
}

export { createContract, createContractFromTx, interactRead, interactWrite, interactWriteDryRun, loadContract, readContract, selectWeightedPstHolder };
//# sourceMappingURL=index.js.map
